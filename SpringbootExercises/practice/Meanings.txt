



// dependency injection can be achieved through IOC and IOC says that a framework such as spring will provide dependencies required
so that the user need not worry about creating those dependencies or objects

IOC COntainer usually is responsible for creating configuring and managing the bean lifecycle once created the beans can be stored in
either the beanfactory or application context

Bean Factory            vs     Application Context

BeanFactory - provides lazy initialization of beans means once when there is a request to create a bean of a class it will create spring bean
Application Context - Eager Initializtion of beans will be done by this meaning as soon as the applicaton starts up the spring framework
will store the beans in application context. also, Application context extends the BeanFactory hence, all the features supported by the
BeanFactory will be inherited by Application Context also internalization and some advance features of spring framework will be
supported by the Application Context.

usually a pojo like can be considered as a java bean but it also follows some design patterns, they will be used in frameworks such as spring


so basically a normal bean can be consider as an object hence, in configuration class we can have multiple objects but if the
@Bean will be kept on top of pojo then class cant be an object and wont be making sense

@Bean usually tells spring that u are defining an object. and that can be inside a configuration class

    explain bean lifecycle properly -
    bean insantiation - bean will be loaded to application context
    dependancy njection - all dependencies of the instantiated bean will be loaded and linked
    @PostConstruct and @init - these annotations in instantiated bean will be invoked they will be invoked only if bean has them
    ready phase - bean will be ready to use
    @PreDestroy - the annotation will be invoked just before removing bean from application context.

    What are the different ways to configure Spring applications?**
    xml base,
    annotation base
    xml base + annotation base
    Component Scanning

    explain spring mvc of architecture
    so first request from frontend reaches dispatcher servlet,
    that will just identify the controller that handles request and sends the name of that to handler mapping,
    then when controller will be reached by handler mapping then that controller will take care of identifying the method that can handle request
    then request will be routed there
    after request will be routed there then in function definition there will be a Model object
    so return that object by setting values
        model.addAttribute("person", new Person());
    then return a view
        return "Person.html"
    then thyemeleaf or some frontend framework can handle that returned model or response
        'name - ' +${person.name}
        'sex - ' +${person.sex}


example5 - @Component is a stereotype annotation and if we keep that on top of POJO then that will also create bean of that POJO to the spring context

example5_1111 - if u want to make sure multiple objects of same type have to be created then create subclasses of that main class
hence, u will be able to create multiple beans using @Component without defining in @Configuration

example6 - @Predestroy - add the annotation ontop of any method that has to be executed before removing the bean from the spring application context
 @PostConstrcut - add the annotation on top of an method so that some functionality can be just invoke after creation of bean

How to create an Object of ApplicationContext -
var context = new AnnotationConfigApplicationContext(Configuration.class);

example7 - context.registerBean() allows u to create bean dynamically

example8 - to use a context with beans created from XML file
use -

var context = new ClassPathXmlApplicationContext("beans.xml");

16. **What is Spring Boot, and what are its key features?**
    springboot is framework part of spring frameworkthat is open source and provides some key benefits such as -

    auto configuration - db connectionvity will be autoconfigured based on application.properties
    embeded server - server such as jetty or tomcat are provided automatically
    embeded database - db such as H2 are easily usable for robust development and testing
    spring boot actuator - provides health metrics of application


    reduces XML base configuration for beans - beans can be configured directly based on stereotype annotations by spring boot

20. **What is Spring Boot Starter?**

    spring boot starter is a pre-configured set of dependencies provided by spring boot that makes quick development of application
    ex -

    spring-boot-starter-web: For developing web applications.
    spring-boot-starter-data-jpa: For data access with JPA.
    spring-boot-starter-security: For adding security features.
    spring-boot-starter-actuator: For production monitoring and management.


Stereotype annotations - by default any stereotype annotation will be created with singletone scope means there will be only one instance
and that will be shared across

@Controller vs the @RestController - with @Controller we usually just need to send response as JSON after manually converting object to json
but with the @RestController there wont be any need to manually convert object to json as that conversion happens in spring automatically


ModelAndView object can help @Controller APIs to convert a object to JSON before sending resp
@RestController uses the Jackson Library to convert an object to JSON before sending response to the frontend

Lombock framework has an annotation -
@Data - keep that on top of pojo so that u can use getters and setters without explicitly defining them

@Slf4j - keep that on top of any class so that u can just use log.info("") and directly debug without explicitly creating an object for log4j

@RequestParam - keep that on a controller api so that u can pass the value like - /home?param1=value&param2=value2

@PathVariable - that will be part of URI eg - /home/{pathVariable1}/{pathVariable2} - not helpful when there will be specialcharacters usually better to use RequestParam

spring-boot-starter-validaton provides annotation such as -
@NotBlank - useful to say that the field cant be empty

@Size - accepts arguments such as min, max

@Lazy will be making sure that whenever bean will be refer whenever there will be requirement to create that bean in context for example - > if repository is autowired to service then only the repo

will be initialized

whereas

@Eager - will be making sure all beans with that annotation will be loaded to context at startup of application

also @Lazy will improve the startup time of application, @Eager will make sure the application is seamless after startup but has low startup time

@SpringBootApplication will be splitted into 3 componenets - @EnableAutoConfiguration, @ComponentScan, @Configuration
@EnableAutoConfiguration - that will be useful to autoconfigure properties from the file - application.properties and auto configures them

reducing the boiler plate code to create dependencies such as datasource connections.
enableautoconfiguration also creates embedded serverver such as Jetty or tomcat automatically which will be very difficult to create manually without springboot

@ComponentScan -that will usually identify all beans such as @Component, @Service, @Controller, @Repository and other custom stereotype annotation

@Valid will trigger spring then say that look for the pojo and validate the request sent by frontend before reaching the controller
though u have to proper validations inside pojo using annotations from jakarta library such as - @NotBlank or @digits

@Scope("request") - that scope makes sure that for every incoming HTTP request there will be a new bean created.
that scope makes sure that for each and every new HTTP request or rest call trigger there will be new bean create

@Scope("session") - that scope will just maintain one bean per session ex - from login to logout of session there will be only one bean in context

so because of that there will be more consistency and these beans will be suitable for transaction related operations.

@Scope("application") - only one bean will be created in entire context of that type unless a new bean will be manually created
context.getBean() // if that will be called n times, there will be only one bean for all


@Transactional - the annotation can be applied on top of a method or class
when applied that makes sure that any particular operation's trnascations related to that method or class annotated with @transactional

will be rollback whenever a current transaction fails ensuring consistency

also

@Transactional(rolbackFor = NullPointerException)
that makes sure that only if a null pointer exception occur transactions will be roll back.

@Entity will just tell to spring to map a class as table in db, u have to use a annotation @table(name = "tablename") if ur table name not same as pojo name
also @Entiry will create table if not present in db

@Column - on top of a field that can be used if u want to use differnt name for field in table compared to pojo field name.

@Transient - transient has to be kept on top of variable and once kept spring makes sure that variable will not be stored in db

Rowmapper is genrally like used to take result table from db resp and then map to collection?

SpringJdbcTemplate - that was introuduced by spring so that most of boilerplate code such as creating / closing connections can be handled by spring
ex -

insertPost(Post post){
    public final JdbcTemplate jdbcTemplate;
    String query = ""insert into contact_msg (name,mobile_num) values (?,?)";"
    jdbcTemplate.update(query, post.getname(), post.getMobile_num());
}

Spring JPA - u just define interface extending JPARepository<Pojo, primaryKeyType>
ex -

@Repository
public interface PublicRepo extends JpaRepository<Product, Long>{
    public Product findProductById(long id);
}

@Service
class Service{
    @Autowired
    protected PublicRepo publicRepo;

    // call findProductById()
}

joins with the spring JPA - Customer and the Orders




Customer.java
@Entity
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "customer_id")
    private Long id;
    private String customerName;

    @ManyToMany
    @JoinTable(
        name = "customer_order",
        joinColumns = @JoinColumn(name="customer_id"),
        inverseJoinColumns = @JoinColumn(name = "order_id")
    )
    public Set<Order> orders;
}

Order.java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String orderDate;

    @ManyToMany
    public Set<Customer> customers;
}

CustomerRepository.java
interface CustomerRepository extends JPARepository<Customer, Long>{
    Customer getById(Long customerId);
}

Service.java
    Customer customer = repo.getById(00000);
    return customer.getOrders();